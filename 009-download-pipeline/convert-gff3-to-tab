#!/usr/bin/python

"""
  gff to tab separated file converter: file is created with the same name as the input gff file with .tab extension, attributes field is preserved 
  so that it might be parsed for custom attributes and multiple comma separeted values in attributes

  gff3 specification: http://www.sequenceontology.org/gff3.shtml
  fields: seqid, source, type, start, end, scrore, strand, phase, attributes
  attributes: ID, Name, Alias, Parent, Target, Gap, Derives_from, Note, Dbxref, Ontology_term        

  create table <schema>.gff_temp (
         seqid         varchar, 
         source        varchar, 
         type          varchar, 
         start         varchar, 
         end_          varchar, 
         scrore        varchar, 
         strand        varchar, 
         phase         varchar, 
         attributes    varchar,
         ID            varchar, 
         Name          varchar, 
         Alias         varchar, 
         Parent        varchar, 
         Target        varchar, 
         Gap           varchar, 
         Derives_from  varchar, 
         Note          varchar, 
         Dbxref        varchar, 
         Ontology_term varchar
  )

  copy cellwall.gff_temp from 'c:\\temp\\python\\test1.tab' 

"""

import sys
import os

# A possible GFF version 3 violation (e.g. JGI data is not version 3)
SPACES_IN_ATTRIBUTES = ("--spaces-in-attributes" in sys.argv)


def gff_attributes_parser(attributes):

    #gff_attributes = {'ID': chr(9), 'Name': chr(9), 'Alias': chr(9), 'Parent': chr(9), 'Target': chr(9), 'Gap': chr(9),
    #                  'Derives_from': chr(9), 'Note': chr(9), 'Dbxref': chr(9), 'Ontology_term': chr(9)}

    # Making case insensitive
    gff_attributes = {'ID': chr(9), 'NAME': chr(9), 'ALIAS': chr(9), 'PARENT': chr(9), 'TARGET': chr(9), 'GAP': chr(9),
                      'DERIVES_FROM': chr(9), 'NOTE': chr(9), 'DBXREF': chr(9), 'ONTOLOGY_TERM': chr(9)}

    attributes_max_index = len(attributes) - 1

    for key in gff_attributes.iterkeys():

        attributes_tag_stage = 0
        attributes_tag_value = ''

        i = attributes.upper().find(key)

        if i >= 0:

           for c in attributes[i:attributes_max_index]:

               if c == ';':

                  break

               if attributes_tag_stage:

                  attributes_tag_value = attributes_tag_value + c

               if c == '=' or (SPACES_IN_ATTRIBUTES and c == ' '):

                  attributes_tag_stage = 1


        gff_attributes[key] = gff_attributes[key] + attributes_tag_value

    tab_separated_attributes = gff_attributes['ID'] + gff_attributes['NAME'] + gff_attributes['ALIAS'] + gff_attributes['PARENT']
    tab_separated_attributes = tab_separated_attributes + gff_attributes['TARGET'] + gff_attributes['GAP'] + gff_attributes['DERIVES_FROM']
    tab_separated_attributes = tab_separated_attributes + gff_attributes[ 'NOTE'] + gff_attributes['DBXREF'] + gff_attributes['ONTOLOGY_TERM']

    return tab_separated_attributes

def gff_to_tab_separated(in_file_name):

    EOL = '\n'

    """
    if os.name == 'nt':

       EOL = '\r\n' 
    """

    out_file_name = in_file_name + '.tab'

    inf = open(in_file_name, 'r')
    outf = open(out_file_name , 'w')

    while 1:

      line_str = inf.readline()

      if not line_str:

         break 

      if ( line_str[0:2] <> "##" ):

         new_line_str = line_str.rstrip(EOL) + gff_attributes_parser(line_str)
          
         outf.write(new_line_str + EOL)

    inf.close()
    outf.close()


if len(sys.argv) - 1 < 1:
        print "Usage: convert-gff-to-tab <gff-file>"
        print ""
        print "This will create a new file <gff-file>.tab"
        sys.exit()

gff_to_tab_separated(sys.argv[1])
